# 8장 병합과 충돌

파생된 브랜치 2개를 하나로 합치는 방법

<br>

## 8.1 병합

<br>

### 8.1.1 하나씩 직접 비교하는 수동 병합

<br>

### 8.1.2 깃으로 자동 병합

<br>

### 8.1.3 병합 방식

-   두 가지 병합 방법 : Fast-Forward 병합, 3-way 병합
-   8-1\_실습 준비.mov

<br>

---

<br>

## 8.2 Fast-Forward 병합

-   가장 간단한 브랜치 병합
-   영어 표현으로 빨리 감기
-   일반적으로 혼자 개발할 때 사용, 혼자 개발할 때 브랜치가 분기되지만 전체 커밋 그림으로 보면 모든 변경 사항은 순차적으로 진행된다. 이런 순차적 커밋에 맞추어 병합을 처리하는 방법이다.

<br>

### 8.2.1 브랜치 생성과 수정 작업

-   8-2\_브랜치 생성과 수정.mov
-   소스트리에서 브랜치를 확인하면 브랜치 경로가 일직선으로 1개만 있다.
-   이런 모양의 브랜치에서 병합 작업을 할 때는 Fast-Forward 방식의 알고리즘이 적용된다.

<br>

### 8.2.2 병합 위치

-   깃의 merge는 브랜치를 병합한다. merge 명령어는 현재 브랜치를 기준으로 다른 브랜치의 모든 커밋을 병합한다.
    ```
    $ git merge 브랜치이름
    ```
-   8-3\_병합 위치.mov

<br>

### 8.2.3 Fast-Forward 병합 적용

-   Fast-Forward 병합은 병합할 하나의 브랜치 파일을 기준 브랜치로 복사하여 수정된 파일을 원본에 그대로 적용한 것과 같다.
-   8-4_Fast-Forward 병합 적용.mov

<br>

---

<br>

## 8.3 3-way 병합

-   여러 개발자와 협업으로 작업하는 경우 사용

<br>

### 8.3.1 브랜치 생성과 수정 작업

-   8-5\_브랜치 생성과 수정 작업.mov

<br>

### 8.3.2 마스터 변경

-   8-6\_ 마스터 변경.mov

<br>

### 8.3.3 공통 조상

-   브랜치 모양이 갈라지는 형태로 나뉠 때는 3-way 방식응 이용
-   두 브랜치를 병합하려면 먼저 분할 기준인 공통 커밋을 찾아야 한다. 이를 공통 조상 커밋이라고 한다. 공통 조상 커밋을 포함하는 브랜치와 새로운 두 브랜치, 이렇게 3개를 하나로 병합해야 한다. 브랜치가 3개 있다고 해서 3-way 병합이라고 한다.
-   깃은 3-way 병합을 할 때 공통 조상 커밋을 자동으로 찾아준다.

<br>

### 8.3.4 병합 커밋

-   병합을 성공적으로 완료한 후에는 새로운 커밋을 하나로 추가로 하나 생성한다. 새로 생성된 커밋을 병합 커밋이라고 한다. 병합 커밋은 2개라는 특징이 있다.
-   8-7\_병합 커밋.mov

<br>

### 8.3.5 병합 메시지

-   "Merge branch 'hotfix'"라고 커밋 메시지가 자동 삽입
-   병합한 후에 새로운 커밋을 하면서 동시에 메시지를 자동 생성
-   직접 커밋 메시지를 작성할 수 있다.
    ```
    $ git merge 브랜치이름 --edit
    ```
-   8-8\_병합 메시지.mov

<br>

---

<br>

## 8.4 브랜치 삭제

-   [Note] 깃 플로(git flow)는 브랜치 관리가 기법이다. 수많은 브랜치 작업을 규격화해서 브랜치를 쉽게 다룰 수 있도록 하는 전략이라고 생각하면 된다. 기본적으로 mater, feature, develop, release, hotfix 브랜치가 있다. 이 중에서 deveop 브랜치는 master 브랜치에 병합한 후에도 삭제하지 않고 계속 유지한다. 이처럼 오랫동안 유지하는 브랜치를 long-running 브랜치라고 한다.

<br>

### 8.4.1 병합 후 삭제

-   브랜치를 삭제할 때는 -d 옵션을 사용한다.

    ```
    $ git branch -d 브랜치이름
    ```

    -   병합을 완료한 브랜치만 삭제

-   병합을 완료하지 않은 브랜치를 삭제하고 싶다면 대문자 -D 옵션을 사용

-   8-9\_브랜치 삭제.mov

<br>

---

<br>

## 8.5 충돌

-   대표적으로 여러 사람과 개발한 코드 일부분이 충돌(conflict)하는 경우. 보통 충돌은 3-way 병합이 실패한 경우

<br>

### 8.5.1 충돌이 생기는 상황

-   대부분의 충돌 원인은 같은 위치의 코드를 동시에 수정했기 때문이다.

<br>

### 8.5.2 실습을 위한 충돌 만들기

-   8-10\_실습을 위한 충돌 만들기.mov
-   Note : 방금 실행한 병합을 취소할 때는 --abort 옵션을 실행
    ```
    $ git merget --abort
    ```

<br>

### 8.5.3 수동으로 충돌 해결

-   충돌한 내용을 수정할 때는 깃에서 표시한 충돌 기호도 함께 삭제
-   Note : 저수준 명령어인 git ls-fiels -u를 사용하여 충돌한 파일들의 집합을 확인할 수 있다.
    ```
    $ git ls-files-u
    ```
-   충돌이 발생하면 병합 커밋으로 자동으로 생성하지 않는다. 충돌을 해결한 후 커밋을 직접 만들어야 한다.
-   8-11\_수동으로 충돌 해결.mov

<br>

### 8.5.4 소스트리에서 충돌 해결

-   8-12\_소스트리에서 충돌 해결.mov

<br>

---

<br>

## 8.6 브랜치 병합 여부 확인

-   깃은 병합한 브랜치와 병합하지 않은 브랜치를 구분하는 옵션을 제공한다.

    ```
    $ git branch --merged
    ```

    -   병합한 브랜치는 별표(\*) 기호로 표시된다.

-   병합하지 않은 브랜치는 --no-merged 옵션으로 확인할 수 있다.
    ```
    $ git branch --no-merged
    ```
-   8-13\_브랜치 병합 여부 확인.mov

<br>

---

<br>

## 8.7 리베이스

-   브랜치를 합치는 방법은 두 가지다. 병합(merge)과 리베이스(rebase)다.
-   리베이스튼 커밋의 트리 구조를 재배열한다. 커밋을 재배열하는 변경 결과가 병합과 유사하다. 실무에서는 merge 명령어보다는 커밋을 재배열하는 리베이스를 더 선호하는 편이다.

<br>

### 8.7.1 베이스

-   모든 브랜치는 뿌리가 있다(master 브랜치 예외). 브랜치는 특정 커밋을 가리키는 포인터다. 가리키는 특정 커밋은 브랜치가 파생된 기준이 된다. 즉, 브랜치는 커밋 하나를 기준으로 새로운 작업을 진행할 수 있는 분리된 작업 경로를 의미한다.

<br>

### 8.7.2 베이스 변경

-   rebase는 베이스 앞에 '다시'를 의미하는 re가 붙은 단어. 파생된 브랜치의 기준이 되는 베이스 커밋을 변경한다는 것이다.
-   커밋의 진행 모습을 단수화하기 위해서 변경.
-   리베이스는 코드의 베이스 분기점을 변경하여 마치 하나의 기찻길처럼 만든다. 여러 갈래로 갈라지지 않아 커밋의 진행 사항을 좀 더 쉽게 파악할 수 있다.

<br>

### 8.7.3 리베이스 vs 병합

-   병합은 파생된 두 브랜치를 하나로 합치는 과정이다. 병합하려면 두 브랜치의 공통 조상 커밋을 먼저 찾아야 한다. 공통 조상 커밋을 찾으면 서로 다르게 커밋이 진행된 두 브랜치를 3-way 방식으로 병합할 수 있다. 공통 조상 커밋은 두 브랜치를 병합하는 베이스 커밋이다.
    병합하는 두 브랜치는 순차적으로 커밋을 비교하여 마지막 최종 커밋을 생성한다.

-   리베이스는 두 브랜치를 서로 비교하지 않고 순차적으로 커밋 병합을 시도한다. 리베이스를 하면 먼저 공통 조상 커밋을 찾는다. 리베이스는 베이스 커밋을 변경하여 두 브랜치의 커밋 위치를 바꾼다. 그리고 파생된 브랜치의 diff를 임시 공간에 잠시 보관한다. mater 브랜치의 커밋1 -> 커밋2 -> 커밋5 -> 커밋6까지 진행한다. 기존 베이스 커밋2에서 커밋6으로 베이스 기준점을 변경한다. 변경하는 기준 브랜치의 마지막 커밋에서 차례로 임시 공간에 저장한 diff를 하나씩 적용한다. 새로운 베이스 기준점을 기반으로 한 브랜체어서 커밋3 -> 커밋4를 커밋6에서 연장하여 수정 재배치한다. 결과적으로 브랜치의 커밋4는 최종 코드로 모든 코드 내용이 반영되어 있다. 커밋4 입장에서 두 브랜치를 병합한 결과물이다.
-   리베이스 결과물을 보면 기존 병합과 두 가지 차이가 있다. 첫째, 3-way 병합은 병합 커밋이지만, 리베이스를 하면 병합 커밋은 없습니다. 둘쩨, 브랜치의 마지막을 가리크는 커밋 위치가 다르다. 브랜치 A는 커밋4를 가리키지마나, master 브랜치는 아직 커밋6를 가리킨다.

<br>

### 8.7.4 리베이스 명령어

-   rebase 명령어를 사용한다. 또는 다른 명령어의 옵션으로 리베이스 기능을 실행할 수 있다.
    ```
    $ git rebase 브랜치
    ```
-   8-14\_리베이스 실습 준비.mov

<br>

### 8.7.5 리베이스 병합

-   리베이스는 병합 기준 브랜치가 master 명령어와 반대이다.
-   리베이스는 병합되는 브랜치 방향이 반대이다.
-   8-15\_리베이스 병합.mov

<br>

### 8.7.6 리베이스되었는지 확인

-   리베이스는 커멋을 변경하는 과정에서 커밋들은 재배치 작업을 한다. 이 과정에서 커밋의 해시 캆이 변경된다.
-   리베이스는 커멋 위치를 변경한다. 따라서 커밋 위치가 변경될 때 해시 값 중복을 방지하려고 새로운 커밋 해시를 생성한다.
-   8-16\_리베이스되었는지 확인.mov

<br>

### 8.7.7 리베이스 후 브랜치

-   일반적으로 병합을 한 후 두 브랜치는 같은 커밋 ID를 가리킨다. 리베이스는 커밋 위치를 재조정할 뿐 브랜치의 HEAD 포인터까지 옮겨 주지는 않는다.
-   리베이스한 후에는 이러한 병합 브랜치의 HEAD를 맞추어야 한다. 리베이스된 브랜치를 병합해야 한다.
-   리베이스하게 되면 복잡한 트리 모양의 구조가 아니라 선형 구조로 브랜치를 변경할 수 있다.
-   8-17_8.7.7 리베이스 후 브랜치.mov

<br>

### 8.7.8 리베이스 충돌과 해결

-   8-18\_리베이스 충돌과 해결.mov

<br>

### 8.7.9 rabase 명령어로 커밋 수정 - 안되는 것 같다.

-   마지막 커밋은 --amend 옵션으로 수정할 수 있다. 이 방법 외에 rebase 명령어로도 최종 커밋을 수정할 수 있다.
-   여러 커밋을 한 커밋으로 묶을 수 있다. -i 옵션
-   8-19_rabase 명령어로 커밋 수정.mov

<br>

### 8.7.10 리베이스할 때 주의할 점

-   저장소를 외부에 공개했다면 공개된 순간부터 커밋은 리베이스를 사용하지 않는 것이 원칙
-   리베이스는 외부로 코드를 푸시하거나 공개하기 전에 로컬에서만 실행하는 것이 좋다. 외부에 공개된 커밋을 리베이스하면 커밋 위치와 해시 값이 변경되어 너무 혼란스럽다.
-   공개된 커밋을 변경할 때는 revert 명령어를 사용한다.

<br>

---

<br>

## 8.8 정리
