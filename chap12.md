# 12장 고급 기능

## 12.1 refs

-   깃에서는 참조하는 해시 값을 ref 목록으로 가지고 있다.

### 12.1.1 실습 환경 준비

-   12-1-1\_실습준비.mov

### 12.1.2 해시

-   생성된 모든 해시 값은 show 명령어로 확인할 수 있다.
    ```
    $ git show 해시값
    ```
-   12-1-2\_해시.mov

### 12.1.3 역조회

-   show 명령어는 해시 값을 사용하여 커밋 정보를 확인한다. 반대로 rev-parse 명령어로 포인터의 해시 값을 알 수 있다.
    ```
    $ git rev-parse master
    ```
-   12-1-3\_역조회.mov

### 12.1.4 참조 목록

-   깃에서는 생성된 해시 값을 참조할 수 있도록 refs 목록을 생성한다. 깃의 모든 refs 목록은 저장소의 숨김 영역인 .git/refs 폴더 안에 저장된다.
-   복잡한 SHA1 해시 값을 쉽게 찾아 사용할 수 있도록 별칭도 쓸 수 있다. 별칭은 .git/refs 폴더 안에서 생성 및 관리할 수 있다.
-   .git/refs 정보는 깃의 기능들을 구현하는 내무 메커니즘이다.

    ```
    $ ls .git/refs -all
    ```

-   처음 저장소를 생성하면 .git/refs 폴더에는 heads와 tags 폴더만 있다.
-   새로운 브랜치를 만들 때마다 해시 값을 가지는 refs 파일들을 생성한다.

    ```
    $ git branch feature
    $ ls .git/refs/heads -all
    ls: -all: No such file or directory
    .git/refs/heads:
    feature master

    ```

-   12-1-4\_참조 목록.mov
-   12-1-5\_참조 목록 파인더에서 보기.mov

---

## 12.2 reflog

-   깃은 안정적인 작업을 유지하려고 참조된 모든 refs를 기록한다. 그리고 내부적으로 작업한 모든 HEAD와 브랜치 포인터를 기록한다. 이때 사용된 포인터들의 기록을 reflog라고 한다.

### 12.2.1 참조 기록

-   reflog는 한 번이라도 사용했더느 HEAD와 브랜치를 기록한다. 하지만 모든 기록을 영구적으로 가지고 있지는 않다. reflog는 시스템에서 정의한 며칠 간의 기록만 보관한다.
    ```
    $ git reflog
    ```
-   12-2-1\_참조 기록.mov

### 12.2.2 기록 확인

-   reflog 기록들은 HEAD@{숫자} 형태. 각 숫자는 작업을 수행한 해시 값을 가리킨다.
-   reflog에 기록된 HEAD@{숫자} 포인터를 이용하여 커밋 정보를 확인할 수 있다.
-   12-2-2\_기록 확인.mov

### 12.2.3 기간 확인

-   커밋ㅢ 로그 기록이 많은 경우 필터링 할 수 있다. 필터링은 특정한 날짜, 시간 등 기준을 적용한다.
    ```
    $ git show master@{yesterday}
    ```
-   깃에서 참조하는 refs의 로그는 reflog 명령어 또는 git log -g 옵션을 사용하여 확인할 수 있다.
    ```
    $ git log -g
    ```
-   12-2-3\_기간 확인.mov

### 12.2.4 기록 유지

-   ref는 현재 로컬 저장소에서 작업한 모든 로그의 참조 기록입니다. 깃은 커밋, 브랜치 등 내부적으로 사용한 모든 객체의 로그를 기록한다. 하지만 refs는 로컬 저장소에만 기록하므로 원격 저장소나 복사, 복제 등으로는 refs 기록을 옮길 수 없다.

---

## 12.3 파일 에터네이션

### 12.3.1 blame

-   blame 기능은 커밋의 메타 정보를 코드 라인별로 같이 결합하여 출력한다. 코드를 수정한 사람이 누구읹, 언제 수정한지를 쉽게 판별할 수 있으며, 메타 정보를 바탕으로 문제를 좀 더 쉽게 파악할 수 있다.

### 12.3.2 실습 환경 준비

-   12-3-1\_실습 준비.mov

### 12.3.3 blame 명령ㅇ어

-   blame 명령어는 개별 파일에서만 동작하며, 명령어 인자 값으로 개별 파일을 전달한다.
    ```
    $ git blame 파일 이름
    ```
-   각 커밋에 대한 해시 값, 작성자, 코드 등 내용도 함께 보여 준다.
-   blame은 누가 코드의 어느 라인을 수정했는지 파악할 때 유용한다.
-   12-3-2_blame.mov

### 12.3.4 옵션 활용

-   소스 코드의 용량이 클 때는 이력 정보도 많이 출력된다. 이때는 -L 옵션을 사용하여 파일의 특정 영역만 지정할 수 있다.
    ```
    $ git blame -L 시작줄, 마지막줄 파일이름
    ```
-   blame 기능은 파일에서 특정한 수정 사항 및 커밋들을 찾는 데 유용ㅇ하다. 수많은 코드 중 수정한 부분만 쉽게 찾아낼 수 있다.
-   옵션
    -   -e : 사용자 이름 대신 이메일을 출력한다.
    -   -w : 공백 문자를 무시한다.
    -   -M : 같은 파일 내에서 복사나 이동을 감지한다.
    -   -C : 다른 파일에서 이동이나 복사된 것을 감지할 수 있다.
-   12-3-3\_옵션 활용.mov

---

## 12.4 replace

-   replace는 기존 커밋을 다른 커밋인 것처럼 변경하는 기능이다.
-   replace를 사용하면 커밋이 많은 오래된 저장소를 분리할 수 있다.

### 12.4.1 실습 환경 준비

-   replace 명령어를 사용하여 저장소를 분리

-   12-4-1\_실습 준비.mov

### 12.4.2 저장소 분리

-   1단게 : 저장소를 분리할 수 있게 새로운 브랜치를 하나 생성. 작업3을 기준으로 브랜치를 만든다.
    ```
    $ git branch worked 1234567
    $ git remote add old https://github.com/~~
    ```
-   2단계 : 1단계에서 원격 저장소를 등록할 때 사용한 별칭 이름을 old로 등록. remote 목록을 확인
    ```
    $ git remote -v
    ```
-   3단계 : 1단계에서 생성한 브랜치를 원격 저장소로 푸시. 이때 로컬 저장소의 브랜치는 분리 기준이 되는 worked 브랜치. 브랜치 이름을 다르게 지정하여 전송.
    ```
    $ git push old worked:master
    ```
-   worked1, worked2, worked3 커밋만 전송된 것을 확인할 수 있다.
-   12-4-2\_저장소 분리.mov

### 12.4.3 저장소 분리

-   앞에서 로컬저장소는 아직 모든 커밋 작업을 가지고 있다. 이제 실제적인 저장소를 분리한다.
-   4단계 : 분리를 하려면 가상의 임시 객체를 하나 생성해야 한다. commit-tree 저수준 깃 명령어 사용
    ```
    $ echo "device history" | git commit-tree work2의해시값^{tree}
    ```
    -   임시 객체는 아직 다른 어떤 객체와도 연결되지 않고, 떨어져 있는 외톨이 객체
-   5단계 : 생성된 임시 객체를 다른 커밋 객체와 리베이스하여 병합
    ```
    $ git rebase --onto 임시객체해시값 해시값
    ```
-   6단계 : 분리 작업한 로컬 저장소를 origin 저장소로 푸시

### 12.4.4 저장소 연결

-   분리된 저장소를 하나로 연결
-   7단계 : 부리된 두 원격 저장소 중에서 마지막에 작업한 커밋으로 원격 저장소를 복제
-   8단계 : 원격 저장소를 패치하여 커밋들을 가져온다. 패치로 가져오는 이유는 수동으로 커밋을 변경하여 병합하기 때문.
-   9단계 : origin/master의 마지막 해시값과 worked/master의 첫번째 해시값을 replace 명령어로 연결한다.
-   12-4-4\_저장소 연결.mov

## 12.5 가비지 콜렉트

-   깃은 저장소를 효율적으로 유지 관리하려고 garbage collect를 지원한다. 또 깃은 가비지를 효과적으로 관리할 수 있도록 별도의 명령어를 제공한다.

### 12.5.1 가비지 garbage

-   가비지는 동적인 언어에서 메모리를 관리하려고 생성한 개념.
-   깃은 시간이 지남에 따라 연결 고리가 없는 고립된 객체들이 생겨 비효율적인 자원 상태가 된다.
-   고립된 객체들을 대표적으로 reset 또는 rebase 등을 자주 할 때 발생한다. 연결고리가 없는 객체들은 불필요하며, 용량만 차지하므로 정리해주는 작업이 필요하다.

### 12.5.2 압축 관리

-   깃의 내부 원리는 SHA1 해시와 객체의 응용이다. 파일 변경, 트리 구조, 커밋 등 대부분의 내부 작업은 객체를 생성하고 연결하는 동작들이다. 커밋들이 실행될 때 이러한 내부 동작으로 연결 고리가 없는 객체가 수업이 생성된다. 깃 내부에 이러한 객체가 많아지면 저장소 용량도 커지고, 객체도 빠르게 관리하기 어렵다. 깃은 이러한 객체를 줄이려고 생성된 객체를 압축한다. 즉, 깃은 연결 고리가 없는 객체들을 pack 파일 형태로 압축하여 저장한다.

### 12.5.3 실행

-   깃은 가비지를 정리하려고 별도의 gc(garbage collect의 약어) 명령어를 제공한다.
-   깃은 내부적으로 가비지 정리가 필요하다고 생각할 때, gc 명령어를 자동으로 실행한다. gc 명령어가 실행되면 오래된 객체들은 삭제하고 저장소 용량도 정리한다.
-   자동 실행 외에 사용자가 직접 gc 명령어를 실행할 수 있다.
    ```
    $ git gc --auto
    ```
-   gc 명령어를 실행할 때는 prune, repack, pack, rerere 등 하위 명령어와 같이 사용한다. gc 명령어가 실행되면 객체를 압축하고 pack 파일 형태로 저장하거나 제거한다.

### 12.5.4 refs 압축

-   gc 명령어는 객체의 압축과 refs를 같이 처리한다. refs를 같이 압축하면 압축하기 전의 파일은 삭제된다. 그리고 새로운 .git/packed-refs 파일을 생성한다.
-   이후 refs가 추가로 변경되면 압축한 packed-refs 값을 수정하지 않고 새로운 refs 파일을 생성한다. 즉, 압축한 이후에는 refs 파일이 2개가 되며, refs 파일이 여러 개 있으면 기본적으로 refs 안에 있는 파일을 먼저 찾는다. 그리고 이후에 압축된 packed-refs 내용을 검색한다.

### 12.5.5 환경 설정

-   gc 명령어의 동작은 환경 설정으로 제어할 수 있다.

    -   gc.reflogExpire : reflog가 보존되는 기간을 설정, 기본값 90일
    -   gc.reflogExpireUnreachable : 기본값 30일
    -   gc.aggressiveWindow: 창의 크기, 기본값 90일
    -   gc.aggressiveDepth: 압축에 사용되는 매개변수, 기본값 50일
    -   gc.pruneExpire: 저장소에 쓰는 다른 프로세스와 동시에 실행될 때 손상을 방지한다.
    -   gc.worktreePruneExpire: 유예 기간을 설정할 수 있다.

-   gc 명령어들의 동작은 gc.auto 항목으로 자동 설정을 허용하지 않을 수도 있고, gc.autopacklimit를 사용하여 최대 압축 숫자를 제어할 수도 있다.

---

## 12.6 prune

-   깃의 가비지를 정리하는 gc 명령어는 몇 가지 명령어와 함께 사용한다. 그중 prune 명령어는 고립된 객체를 정리하는 내부 유틸리티이다.

### 12.6.1 고립된 객체

-   어떤 객체를 새로운 커밋으로 재설정하면 참조 링크가 해제되는데, 이것은 해당 객체가 더 이상 필요하지 않다는 것이다. 즉, 불필요한 객체가 생기는 것이다.
-   고립된 객체는 객체 간 연결 고리가 끊겨 명령어를 사용해도 해당 객체에 접근할 수 없는 객체를 의미한다. 고립된 객체는 불필요하므로 정리해야 한다. 깃 자체적으로 완벽하게 정리하기 어려우므로 수동으로 정리해야 한다.

### 12.6.2 실습 환경 준비

-   12-6-1\_실습 준비.mov

### 12.6.3 객체 삭제

-   prune 명령어는 고립된 객체를 정리하는 기능
-   리베이스 또는 리셋 등 명령어 작업들은 고립된 객체를 생성한다. 실습을 위해 인위적으로 고립된 객체 생성
    -   커밋을 --hard 옵션을 사용하여 리셋하더라고 내부적으로 생성한 객체를 물리적으로 삭제하지 않는다. 삭제한 후에도 이전의 커밋으로 직접 체크아웃 할 수 있다.
    -   리셋은 단지 객체 연결 고리를 해제하여 끊긴 상태로 처리하며, 이 커밋은 깃 내부 저정소에 고립된 객체로 남아 있다.
-   12-6-2\_객체 삭제.mov

### 12.6.4 객체 정리

-   리셋으로 제거된 객체는 삭제되지 않고 고립된 객체가 된다. 리셋으로 객체까지 완벽하게 삭제하려면 prune 명령어를 사용한다.
-   두 가지 옵션
    -   --dry-run : 실행하지 않고 작업한 내역만 출력
    -   --verbose : 작업한 결과를 출력

```
$ git prune --dry-run --verbose
```

    - 실행 결과 어떤 메시지도 출력되지 않는다.
    - 깃 내부에 고립된 객체가 없어 prune 동작 자체가 실행되지 않은 것
    - 이전에 리셋으로 제거한 객체는? 리셋은 단지 커밋의 참고 연결 고리만 해제한 것. 깃은 생성된 객체를 쉽게 삭제하는 것을 허용하지 않는다. 참고 연결 고리만 해제한 객체와 실제 고립된 객체는 서로 다른다.

-   고립된다는 것은 어떤 명령어로도 해당 객체에 접근할 수 없어야 한다는 의미
-   깃은 참조된 모든 객체의 연결 고리를 reflog에 이중으로 기록한다. reflog는 깃에서 참조된 모든 객체의 기록을 일정 기간 유지하는 역할을 한다. 리셋 명령만으로는 객체와 연결한 모든 고리를 완벽하게 제거할 수 없다는 의미
-   prune 명령어를 실행하려면 완벽하게 고립된 객체여야 한다. 따라서 reflog에 기록된 연결 고리 링크도 같이 제거해야 한다. reflog는 일정 기간이 지나면 자동으로 없어지지만, 실습을 위해 연결 고리를 직접 제거한다.
    ```
    $ git reflog expire --expire=now --expire-unreachable=now --all
    ```
    -   현재를 기준으로 그보다 오래된 모든 reflog는 만료한다.
-   --dry-run 옵션은 정리 작업을 실제로 진행하지 않고, 예상되는 작업 결과만 미리 보여준다. 완전히 삭제하려면 --expire 옵션 사용
    ```
    $ git prune --expire now -v
    ```
-   일반적으로 prune 명령어는 개발자가 직접 실행하지 않는 편. 참고로 prune 명령어는 gc 명령어의 하위 명령어

-   12-6-3\_객체 정리.mov

### 12.6.5 원격 작업

-   보통 prune 명령어는 로컬 환경에서 실행한다. 하지만 고립된 객체는 원격 저장소에도 있을 수 있다. remote/fetch 명령어를 같이 조합하면 원격 저장소에서도 prune 명령어를 실행할 수 있다.
    ```
    $ git remote prune
    ```
-   원격 저장소의 브랜치를 병합한 후 삭제한다. 삭제된 원격 저장소 브랜치는 더 이상 참조할 수 없다.
    ```
    $ git fetch --prune
    ```
    -   fetch --prune은 오래된 브랜치를 정리한다. 원격 저장소에 연결한 후 제거하기 전에 최신 상태를 먼저 가져온다.

---

## 12.7 rerere : resue recoreded resolution

-   깃은 협업 작업을 할 때 발생한 문제들을 충돌이라는 형태로 알려 준다.

### 12.7.1 동일한 충돌

-   협업 중 발생하는 여러 문제 중에서 일부는 같은 유형의 문제이다.
-   rerere는 어떤 문제로 충돌이 발생할 때 이를 기록한다.
-   rerere 기능을 활성화하면, 깃은 충돌을 해결할 때마다 해결한 문제의 유형을 기록한다. 향후 다시 발생한다면, 미리 기록한 해결 정보를 바탕으로 자동으로 적용한다.

### 12.7.2 활성화

-   다음 명령어로 활성화
    ```
    $ git config rerere.enable.true
    ```
-   로컬의 전체 저장소에 모두 적용하고자 한다면 --global 옵션을 같이 사용

### 12.7.3 실습 준비

-   12-7-1\_실습 준비.mov

### 12.7.4 충돌 기록

-   rerere 기능은 우리가 작업한 해결 유형을 별도로 기록합니다.
-   12-7-2\_충돌 기록.mov

### 12.7.5 자동 해결

-   12-7-3\_자동 해결.mov

---

## 12.8 정리

-   일반적으로 사용자는 기의 고급 기능까지 알 필요가 없다. 하지만 자신의 프로젝트에서 중요한 자리를 맡았거나 운영한다면 좀 더 많은 기능을 알고 있는 것이 좋다.
